# Срезы

*Срез* (slice) — ключевая структура данных в Go. Это массив изменяемой длины, как *list* в питоне или *Array* в js. Обычно в программах на Go оперируют именно срезами, «чистые» массивы встречаются намного реже.

Срез определяется только типом элементов, но не их количеством. Чтобы создать срез ненулевой длины, используют встроенную функцию `make()`. Здесь мы создаем срез из трех пустых строк:

```go
s := make([]string, 3)
fmt.Printf("empty: %#v\n", s)
// empty: []string{"", "", ""}
```

Шаблон `%#v` возвращает «внутреннее представление» значения, примерно как `repr()` в питоне.

С элементами среза можно работать точно так же, как с элементами массива:

```go
s[0] = "a"
s[1] = "b"
s[2] = "c"

fmt.Println("set:", s)
// set: [a b c]

fmt.Println("get:", s[2])
// get: c
```

`len()` возвращает длину среза:

```go
fmt.Println("len:", len(s))
// len: 3
```

Срез можно инициализировать при объявлении:

```go
s := []string{"a", "b", "c"}
fmt.Println("init:", s)
// init: [a b c]
```

В отличие от массива, в срез можно добавлять новые элементы через встроенную функцию `append()`. Функция возвращает новый срез:

```go
s := []string{"a", "b", "c"}

fmt.Println("src:", s)
// src: [a b c]

s = append(s, "d")
s = append(s, "e", "f")
fmt.Println("upd:", s)
// upd: [a b c d e f]
```

<details>
    <summary><strong>Warning</strong></summary>

*Всегда используйте значение, которое возвращает `append()`. Вот так делать не стоит:*

```go
append(s, "d")
fmt.Println("upd:", s)
```

*Дело в том, что срез сам по себе не хранит данные, это ссылка на конкретный массив. Если в массиве нет места для нового элемента, `append()` создаст новый массив побольше, скопирует в него старые элементы, добавит новый элемент и вернет ссылку на новый массив. Если эту ссылку проигнорировать, новый срез вы потеряете.*

</details>

Срез можно скопировать через встроенную функцию `copy()`. Здесь создаем пустой срез `dst` такой же длины, как `s`, и копируем в него элементы `s`:

```go
src := []string{"a", "b", "c", "d", "e", "f"}
dst := make([]string, len(src))

copy(dst, src)
fmt.Println("copy:", dst)
// copy: [a b c d e f]
```

Срезы поддерживают... срезы (отсюда их название). Выражение `slice[from:to]` вернет срез от элемента с индексом `from` включительно до элемента с индексом `to` не включительно:

```go
s := []string{"a", "b", "c", "d", "e", "f"}

sl1 := s[2:5]
fmt.Println("sl1:", sl1)
// sl1: [c d e]
```

Этот срез включает все элементы, кроме `s[5]`:

```go
sl2 := s[:5]
fmt.Println("sl2:", sl2)
// sl2: [a b c d e]
```

А этот срез включает элементы от `s[2]` и до конца:

```go
sl3 := s[2:]
fmt.Println("sl3:", sl3)
// sl3: [c d e f]
```

# Срезы и строки

Строку можно преобразовать в срез байт и обратно:

```go
str := "го!"
bytes := []byte(str)

fmt.Println(bytes)
// [208 179 208 190 33]

fmt.Println(str == string(bytes))
// true
```

Строку можно преобразовать в срез unicode-символов (Go называет их *рунами*). Одна руна может занимать несколько байт (что и произошло с рунами `г` и `о`):

```go
runes := []rune(str)

fmt.Println(runes)
// [1075 1086 33]

fmt.Println(str == string(runes))
// true
```

[Задание 1. Укорот байтовой строки](tasks/task1.md)

[<< Назад](arrays.md) [На главную](content.md) [Вперед >>](maps.md)