# Функции

*Функция* — центральная конструкция языка. Вот несколько примеров.

Эта функция принимает два целых числа и возвращает их сумму:

```go
func sum(a int, b int) int {
    return a + b
}
```

Результат возвращается явно, через `return`.

Если у нескольких идущих подряд параметров один и тот же тип, их можно «схлопнуть» и указать тип только для последнего:

```go
func sum(a, b, c int) int {
    return a + b + c
}
```

Функция может возвращать несколько значений. В этом примере — частное и остаток от деления одного числа на другое:

```go
func divide(divisible, divisor int) (int, int) {
    quotient := divisible / divisor
    remainder := divisible % divisor
    return quotient, remainder
}
```

Результат вызова можно сразу разложить по переменным:

```go
q, r := divide(10, 3)
fmt.Println("10 / 3 =", q)
// 10 / 3 = 3
fmt.Println("10 % 3 =", r)
// 10 % 3 = 1
```

Или проигнорировать одно из значений с помощью пустого идентификатора `_`:

```go
_, r = divide(42, 2)
if r == 0 {
    fmt.Println("42 is divisible by 2")
}
// 42 is divisible by 2
```

# Вариативные функции

Функция может принимать произвольное количество аргументов в «хвосте» (как `*args` в питоне или `...args` в js). Например, так ведет себя `fmt.Println()`. В Go такие функции называют *вариативными* (variadic).

Эта функция суммирует целые числа:

```go
func sum(nums ...int) {
    fmt.Print(nums, " -> ")
    total := 0
    for _, num := range nums {
        total += num
    }
    fmt.Println(total)
}
```

Можно передавать индивидуальные аргументы, как у обычной функции:

```go
sum(1, 2)
// [1 2] -> 3
sum(1, 2, 3)
// [1 2 3] -> 6
```

А можно передать срез, преобразовав его в список аргументов с помощью `...`:

```go
nums := []int{1, 2, 3, 4}
sum(nums...)
// [1 2 3 4] -> 10
```

# Анонимные функции

Go поддерживает *анонимные функции*. Работают они как обычные, но не имеют названия (как лямбды в питоне или стрелочные функции в js).

Чаще всего анонимные функции используют, чтобы вернуть из *функции другую функцию*. В примере ниже `intSeq()` возвращает функцию-генератор, которая при каждом вызове выдает очередное значение счетчика `i`. Генератор использует переменную, определенную во внешней функции — то есть образует *замыкание* (closure):

```go
func intSeq() func() int {
    i := 0
    return func() int {
        i++
        return i
    }
}
```

Результат вызова `intSeq()` — функцию-генератор — мы записываем в переменную `next`. У `next` собственное значение счетчика `i`, которое увеличивается при каждом вызове:

```go
next := intSeq()

fmt.Println(next())
// 1
fmt.Println(next())
// 2
fmt.Println(next())
// 3
```

Если создать еще один генератор — он будет обладать собственным счетчиком `i`:

```go
gen := intSeq()
fmt.Println(gen())
// 1
fmt.Println(gen())
// 2
```

Иногда анонимную функцию передают как аргумент другой функции. Пример из пакета `sort`:

```go 
func Search(n int, f func(int) bool) int
```

`Search()` находит наименьшее `i` из диапазона `[0, n)`, для которого функция-предикат `f(i)` вернет `true`. В качестве предиката удобно использовать анонимную функцию:

```go 
a := []int{1, 2, 4, 8, 16, 32, 64, 128}
x := 53

// ближайший сверху к `x` элемент среза `a`
closest := sort.Search(len(a), func(i int) bool { return a[i] >= x })

fmt.Println(a[closest], "is the closest to", x)
// 64 is the closest to 53
```

[Задание 1. Фильтр для коллекции](tasks/task1.md)

[<< Назад](content.md) [Вперед >>](pointers.md)